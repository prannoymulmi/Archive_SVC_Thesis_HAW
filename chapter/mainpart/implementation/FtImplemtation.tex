\newpage
\section{Fault-Tolerance and Maintenance Implementation}
The MARS system is very susceptible to different kinds of errors due to the architectural factors mentioned in the previous chapters. Therefore, a fault tolerant
system is needed which would try to recover in case of any transient errors. For the Archive service an open source framework
named Hangfire is used for implementing the design in Section \ref{sec:ftDesign}. This framework is used because it provides
the functionality mentioned in the design section including many additional features i.e. reliability, easy maintainability and simplicity. It can be called
reliable because when a background process is created, the usage of this framework would persist the input parameters, retry times, method name etc., in a database. 
This is also known as the Forget and Fire feature \cite{Hangfire}. It would
ensure that the jobs triggered once will always be executed and retried. As an example, if the
Archive service restarts during a running process, in the general case the job cannot be recovered. However, this framework will check if 
there are any incomplete jobs and will start them automatically. This Forget and Fire 
feature ensures that the triggered processes would always run compared to the native threading offered by ASP .NET Core.
Listing \ref{lst:hangfire}
shows the simplicity of how a job retry can be configured in case of an exception. One of the biggest disadvantages of this framework is that it is 
tightly coupled
with a database. If there is a connection issue present between the Archive service and the database the whole service will be facing a downtime. However, the 
benefits this framework provides outweighs its disadvantages.

\begin{lstlisting}[language={[Sharp]C}, caption={Hangfire retry attempt configuration}, captionpos=b,label={lst:hangfire}]
private IServiceCollection BuildServices(IServiceCollection services)
{
    // hangfire job filter
    GlobalJobFilters.Filters.Add(new AutomaticRetryAttribute { Attempts = 4 });
}
\end{lstlisting}

\subsubsection{AOP Logging}
Logging is very important part of the service as it gives the maintainers key information of what has happened to the system. This makes logging important
in each part of the system which leads to copying of the logging logic to the different components in the archive service violating the SOLID \cite{Hotop2015} principles. 
To solve this issue the interceptor pattern is used. Using this pattern a decorator would be added in the class which wants to include the common
logging logic. Listing \ref{lst:interceptor} shows the implementation of the decorator "Intercept("logger")" which is injected in the class. The 
classes decorated with attribute would have a logging logic triggered. Listing \ref{lst:interceptor} shows the main logic for the logging where a success message
with all the method arguments, time elapsed would be printed in case of a successful run and will log the exception in case of failure. This aids in the maintenance
of the system as new feature are added only the decorator must be added to log the start, success or exception of the method.

\newpage
\begin{lstlisting}[language={[Sharp]C}, caption={Interceptor decorator example}, captionpos=b,label={lst:interceptor}]
[Intercept("logger")]
public class ArchiveFile: IArchiveFile
{
    public ArchiveFile(IFileClient fileClient)
    {
        _fileClient = fileClient;
    }
}
\end{lstlisting}            

\begin{lstlisting}[language={[Sharp]C}, caption={Interceptor logger logic implementation}, captionpos=b,label={lst:interceptor}]
private async Task InterceptAsync(IInvocation invocation)
{
//Before method execution
var stopwatch = Stopwatch.StartNew();

try
{
    //Calling the actual method, but execution has not been finished yet
    invocation.Proceed();

    //Wait task execution and modify return value
    if (invocation.Method.ReturnType == typeof(Task))
    {
        try
        {
            await InternalAsyncHelper.AwaitTaskWithPostActionAndFinally(
                (Task) invocation.ReturnValue,
                exception =>
                {
                    if (exception == null)
                    {
                        Console.WriteLine("Success: Class Name: {0} Method: {1}  Duration: {2:0.000} ms, Arugments: {3}", GetClassName(invocation),
                            invocation.MethodInvocationTarget.Name, stopwatch.Elapsed.TotalMilliseconds, GetMethodArguments(invocation));
                    }
                    else
                    {
                        Console.WriteLine(exception);
                        throw exception;
                    }
                    
                });
        }
        catch (Exception)
        {
            Console.WriteLine("Exception occured in async call");
        }
        
    }
}
\end{lstlisting}            
